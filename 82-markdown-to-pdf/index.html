<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown to PDF Converter</title>
    <style>
/* Reset and Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background-color: #f5f5f5;
    color: #333;
    line-height: 1.6;
}

/* Container */
.container {
    max-width: 1800px;
    margin: 0 auto;
    height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Header */
.header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 1.5rem 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.header h1 {
    font-size: 1.8rem;
    font-weight: 600;
}

.header-actions {
    display: flex;
    gap: 1rem;
}

/* Buttons */
.btn {
    padding: 0.6rem 1.2rem;
    border: none;
    border-radius: 6px;
    font-size: 0.95rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
}

.btn-primary {
    background-color: #10b981;
    color: white;
}

.btn-primary:hover {
    background-color: #059669;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
}

.btn-secondary {
    background-color: rgba(255,255,255,0.2);
    color: white;
    border: 1px solid rgba(255,255,255,0.3);
}

.btn-secondary:hover {
    background-color: rgba(255,255,255,0.3);
}

/* Main Content */
.main-content {
    flex: 1;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0;
    overflow: hidden;
}

/* Panes */
.editor-pane,
.preview-pane {
    display: flex;
    flex-direction: column;
    background-color: white;
    overflow: hidden;
}

.editor-pane {
    border-right: 2px solid #e5e7eb;
}

.pane-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.5rem;
    background-color: #f9fafb;
    border-bottom: 1px solid #e5e7eb;
}

.pane-header h2 {
    font-size: 1.1rem;
    font-weight: 600;
    color: #374151;
}

/* Editor Toolbar */
.editor-toolbar,
.preview-toolbar {
    display: flex;
    gap: 0.5rem;
}

.toolbar-btn {
    width: 32px;
    height: 32px;
    border: 1px solid #d1d5db;
    background-color: white;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
    transition: all 0.2s ease;
}

.toolbar-btn:hover {
    background-color: #f3f4f6;
    border-color: #9ca3af;
}

.toolbar-btn:active {
    background-color: #e5e7eb;
}

/* Markdown Editor */
#markdownEditor {
    flex: 1;
    width: 100%;
    padding: 1.5rem;
    border: none;
    outline: none;
    font-family: 'Courier New', Courier, monospace;
    font-size: 14px;
    line-height: 1.6;
    resize: none;
    background-color: #fafafa;
}

#markdownEditor:focus {
    background-color: white;
}

/* Editor Stats */
.editor-stats {
    padding: 0.75rem 1.5rem;
    background-color: #f9fafb;
    border-top: 1px solid #e5e7eb;
    display: flex;
    gap: 2rem;
    font-size: 0.85rem;
    color: #6b7280;
}

/* Preview Content */
.preview-content {
    flex: 1;
    padding: 2rem;
    overflow-y: auto;
    background-color: white;
}

.preview-placeholder {
    color: #9ca3af;
    text-align: center;
    padding: 4rem 2rem;
    font-style: italic;
}

/* Preview Markdown Styles */
.preview-content h1,
.preview-content h2,
.preview-content h3,
.preview-content h4,
.preview-content h5,
.preview-content h6 {
    margin-top: 24px;
    margin-bottom: 16px;
    font-weight: 600;
    line-height: 1.25;
}

.preview-content h1 {
    font-size: 2em;
    border-bottom: 2px solid #eaecef;
    padding-bottom: 0.3em;
}

.preview-content h2 {
    font-size: 1.5em;
    border-bottom: 1px solid #eaecef;
    padding-bottom: 0.3em;
}

.preview-content h3 { font-size: 1.25em; }
.preview-content h4 { font-size: 1em; }
.preview-content h5 { font-size: 0.875em; }
.preview-content h6 { font-size: 0.85em; }

.preview-content p {
    margin-bottom: 16px;
}

.preview-content a {
    color: #0366d6;
    text-decoration: none;
}

.preview-content a:hover {
    text-decoration: underline;
}

.preview-content code {
    background-color: rgba(27,31,35,0.05);
    border-radius: 3px;
    font-size: 85%;
    margin: 0;
    padding: 0.2em 0.4em;
    font-family: 'Courier New', Courier, monospace;
}

.preview-content pre {
    background-color: #f6f8fa;
    border-radius: 6px;
    font-size: 85%;
    line-height: 1.45;
    overflow: auto;
    padding: 16px;
    margin-bottom: 16px;
}

.preview-content pre code {
    background-color: transparent;
    padding: 0;
}

.preview-content blockquote {
    border-left: 4px solid #dfe2e5;
    color: #6a737d;
    padding: 0 15px;
    margin: 0 0 16px 0;
}

.preview-content ul,
.preview-content ol {
    margin-bottom: 16px;
    padding-left: 2em;
}

.preview-content li {
    margin-bottom: 0.25em;
}

.preview-content table {
    border-collapse: collapse;
    border-spacing: 0;
    width: 100%;
    margin-bottom: 16px;
}

.preview-content table th,
.preview-content table td {
    border: 1px solid #dfe2e5;
    padding: 6px 13px;
}

.preview-content table th {
    background-color: #f6f8fa;
    font-weight: 600;
}

.preview-content table tr:nth-child(2n) {
    background-color: #f6f8fa;
}

.preview-content hr {
    border: 0;
    border-top: 2px solid #eaecef;
    margin: 24px 0;
}

.preview-content img {
    max-width: 100%;
    height: auto;
}

/* Modal */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    animation: fadeIn 0.3s ease;
}

.modal.active {
    display: flex;
    align-items: center;
    justify-content: center;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.modal-content {
    background-color: white;
    border-radius: 12px;
    width: 90%;
    max-width: 600px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    animation: slideUp 0.3s ease;
}

@keyframes slideUp {
    from {
        transform: translateY(50px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5rem 2rem;
    border-bottom: 1px solid #e5e7eb;
}

.modal-header h2 {
    font-size: 1.5rem;
    font-weight: 600;
    color: #1f2937;
}

.close-btn {
    width: 32px;
    height: 32px;
    border: none;
    background-color: transparent;
    font-size: 1.5rem;
    cursor: pointer;
    color: #6b7280;
    transition: color 0.2s ease;
}

.close-btn:hover {
    color: #1f2937;
}

.modal-body {
    padding: 2rem;
}

.modal-footer {
    padding: 1.5rem 2rem;
    border-top: 1px solid #e5e7eb;
    display: flex;
    justify-content: flex-end;
    gap: 1rem;
}

/* Settings Sections */
.settings-section {
    margin-bottom: 2rem;
}

.settings-section h3 {
    font-size: 1rem;
    font-weight: 600;
    color: #374151;
    margin-bottom: 1rem;
}

.settings-section select {
    width: 100%;
    padding: 0.6rem;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-size: 0.95rem;
    background-color: white;
    cursor: pointer;
}

.settings-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
}

.setting-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.setting-item label {
    font-size: 0.9rem;
    color: #4b5563;
    white-space: nowrap;
}

.setting-item input[type="number"] {
    width: 70px;
    padding: 0.4rem;
    border: 1px solid #d1d5db;
    border-radius: 4px;
    font-size: 0.9rem;
}

.setting-item input[type="color"] {
    width: 50px;
    height: 36px;
    border: 1px solid #d1d5db;
    border-radius: 4px;
    cursor: pointer;
}

.setting-item span {
    font-size: 0.85rem;
    color: #6b7280;
}

/* Preset Buttons */
.preset-buttons {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
}

/* Print Styles */
@media print {
    .header,
    .editor-pane,
    .pane-header,
    .editor-stats,
    .modal {
        display: none !important;
    }

    .main-content {
        display: block;
    }

    .preview-pane {
        border: none;
    }

    .preview-content {
        padding: 0;
        max-width: none;
    }

    .preview-content h1,
    .preview-content h2,
    .preview-content h3,
    .preview-content h4,
    .preview-content h5,
    .preview-content h6 {
        page-break-after: avoid;
    }

    .preview-content pre,
    .preview-content blockquote,
    .preview-content table {
        page-break-inside: avoid;
    }
}

/* Responsive Design */
@media (max-width: 1024px) {
    .main-content {
        grid-template-columns: 1fr;
    }

    .editor-pane {
        border-right: none;
        border-bottom: 2px solid #e5e7eb;
    }

    .settings-grid {
        grid-template-columns: 1fr;
    }
}
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <h1>üìù Markdown to PDF Converter</h1>
            <div class="header-actions">
                <button id="settingsBtn" class="btn btn-secondary">‚öôÔ∏è Settings</button>
                <button id="exportBtn" class="btn btn-primary">üìÑ Export PDF</button>
            </div>
        </header>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Editor Pane -->
            <div class="editor-pane">
                <div class="pane-header">
                    <h2>‚úèÔ∏è Editor</h2>
                    <div class="editor-toolbar">
                        <button class="toolbar-btn" onclick="insertMarkdown('**', '**')" title="Bold">
                            <strong>B</strong>
                        </button>
                        <button class="toolbar-btn" onclick="insertMarkdown('*', '*')" title="Italic">
                            <em>I</em>
                        </button>
                        <button class="toolbar-btn" onclick="insertMarkdown('`', '`')" title="Code">
                            <code>&lt;/&gt;</code>
                        </button>
                        <button class="toolbar-btn" onclick="insertMarkdown('[', '](url)')" title="Link">
                            üîó
                        </button>
                        <button class="toolbar-btn" onclick="insertMarkdown('## ', '')" title="Heading">
                            H
                        </button>
                        <button class="toolbar-btn" onclick="insertList()" title="List">
                            ‚â°
                        </button>
                    </div>
                </div>
                <textarea id="markdownEditor"
                          placeholder="Type your markdown here...

# Sample Document

This is a **bold** word and this is *italic*.

## Features

- Lists
- **Bold** and *italic*
- \`Code blocks\`
- [Links](https://example.com)
- And more!"></textarea>
                <div class="editor-stats">
                    <span id="wordCount">Words: 0</span>
                    <span id="charCount">Characters: 0</span>
                </div>
            </div>

            <!-- Preview Pane -->
            <div class="preview-pane">
                <div class="pane-header">
                    <h2>üëÅÔ∏è Preview</h2>
                    <div class="preview-toolbar">
                        <button class="toolbar-btn" onclick="refreshPreview()" title="Refresh">
                            üîÑ
                        </button>
                    </div>
                </div>
                <div id="preview" class="preview-content">
                    <p class="preview-placeholder">Your rendered markdown will appear here...</p>
                </div>
            </div>
        </div>

        <!-- Settings Modal -->
        <div id="settingsModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>‚öôÔ∏è Document Settings</h2>
                    <button class="close-btn" onclick="closeSettings()">&times;</button>
                </div>
                <div class="modal-body">
                    <!-- Font Settings -->
                    <div class="settings-section">
                        <h3>Font Family</h3>
                        <select id="fontFamily" onchange="updatePreview()">
                            <option value="Georgia, serif">Serif (Georgia)</option>
                            <option value="Arial, sans-serif">Sans-serif (Arial)</option>
                            <option value="'Helvetica Neue', Helvetica, sans-serif">Helvetica</option>
                            <option value="'Times New Roman', Times, serif">Times New Roman</option>
                            <option value="'Courier New', Courier, monospace">Monospace</option>
                        </select>
                    </div>

                    <!-- Font Sizes -->
                    <div class="settings-section">
                        <h3>Font Sizes</h3>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <label for="bodySize">Body Text:</label>
                                <input type="number" id="bodySize" value="16" min="10" max="24" onchange="updatePreview()">
                                <span>px</span>
                            </div>
                            <div class="setting-item">
                                <label for="h1Size">Heading 1:</label>
                                <input type="number" id="h1Size" value="32" min="20" max="48" onchange="updatePreview()">
                                <span>px</span>
                            </div>
                            <div class="setting-item">
                                <label for="h2Size">Heading 2:</label>
                                <input type="number" id="h2Size" value="24" min="16" max="36" onchange="updatePreview()">
                                <span>px</span>
                            </div>
                            <div class="setting-item">
                                <label for="h3Size">Heading 3:</label>
                                <input type="number" id="h3Size" value="20" min="14" max="30" onchange="updatePreview()">
                                <span>px</span>
                            </div>
                        </div>
                    </div>

                    <!-- Colors -->
                    <div class="settings-section">
                        <h3>Colors</h3>
                        <div class="settings-grid">
                            <div class="setting-item">
                                <label for="bgColor">Background:</label>
                                <input type="color" id="bgColor" value="#ffffff" onchange="updatePreview()">
                            </div>
                            <div class="setting-item">
                                <label for="textColor">Text:</label>
                                <input type="color" id="textColor" value="#333333" onchange="updatePreview()">
                            </div>
                            <div class="setting-item">
                                <label for="headingColor">Headings:</label>
                                <input type="color" id="headingColor" value="#2c3e50" onchange="updatePreview()">
                            </div>
                            <div class="setting-item">
                                <label for="linkColor">Links:</label>
                                <input type="color" id="linkColor" value="#0366d6" onchange="updatePreview()">
                            </div>
                        </div>
                    </div>

                    <!-- Presets -->
                    <div class="settings-section">
                        <h3>Presets</h3>
                        <div class="preset-buttons">
                            <button class="btn btn-secondary" onclick="applyPreset('default')">Default</button>
                            <button class="btn btn-secondary" onclick="applyPreset('dark')">Dark</button>
                            <button class="btn btn-secondary" onclick="applyPreset('minimal')">Minimal</button>
                            <button class="btn btn-secondary" onclick="applyPreset('serif')">Classic Serif</button>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="resetSettings()">Reset to Default</button>
                    <button class="btn btn-primary" onclick="closeSettings()">Done</button>
                </div>
            </div>
        </div>
    </div>

    <script>
// Custom Markdown Parser - Client-side JavaScript Implementation
// Built from scratch without external libraries

class MarkdownParser {
    constructor() {
        this.html = [];
    }

    parse(markdown) {
        if (!markdown) return '';

        this.html = [];
        const lines = markdown.split('\n');

        let i = 0;
        while (i < lines.length) {
            const line = lines[i];

            // Skip empty lines
            if (!line.trim()) {
                i++;
                continue;
            }

            // Code block
            if (line.trim().startsWith('```')) {
                i = this.parseCodeBlock(lines, i);
                continue;
            }

            // Headers
            if (line.startsWith('#')) {
                this.parseHeader(line);
                i++;
                continue;
            }

            // Horizontal rule
            if (/^(\*\*\*+|---+|___+)\s*$/.test(line.trim())) {
                this.html.push('<hr>');
                i++;
                continue;
            }

            // Blockquote
            if (line.trim().startsWith('>')) {
                i = this.parseBlockquote(lines, i);
                continue;
            }

            // Unordered list
            if (/^[\s]*[-*+]\s+/.test(line)) {
                i = this.parseUnorderedList(lines, i);
                continue;
            }

            // Ordered list
            if (/^[\s]*\d+\.\s+/.test(line)) {
                i = this.parseOrderedList(lines, i);
                continue;
            }

            // Table
            if (line.includes('|') && i + 1 < lines.length && lines[i + 1].includes('|')) {
                if (/^\|?[\s]*[-:]+[\s]*\|/.test(lines[i + 1])) {
                    i = this.parseTable(lines, i);
                    continue;
                }
            }

            // Paragraph
            i = this.parseParagraph(lines, i);
        }

        return this.html.join('\n');
    }

    parseHeader(line) {
        const match = line.match(/^(#{1,6})\s+(.+)$/);
        if (match) {
            const level = match[1].length;
            const content = this.parseInline(match[2].trim());
            this.html.push(`<h${level}>${content}</h${level}>`);
        }
    }

    parseCodeBlock(lines, startIndex) {
        const line = lines[startIndex].trim();
        const langMatch = line.match(/^```(\w+)?/);
        const language = langMatch && langMatch[1] ? langMatch[1] : '';

        const codeLines = [];
        let i = startIndex + 1;

        while (i < lines.length && !lines[i].trim().startsWith('```')) {
            codeLines.push(lines[i]);
            i++;
        }

        const codeContent = this.escapeHtml(codeLines.join('\n'));
        const langClass = language ? ` class="language-${language}"` : '';

        this.html.push(`<pre><code${langClass}>${codeContent}</code></pre>`);

        return i + 1;
    }

    parseBlockquote(lines, startIndex) {
        const quoteLines = [];
        let i = startIndex;

        while (i < lines.length && lines[i].trim().startsWith('>')) {
            const content = lines[i].trim().replace(/^>\s?/, '');
            quoteLines.push(content);
            i++;
        }

        const quoteText = quoteLines.join('\n');
        const quoteHtml = this.parseInline(quoteText);

        this.html.push(`<blockquote>${quoteHtml}</blockquote>`);

        return i;
    }

    parseUnorderedList(lines, startIndex) {
        const listItems = [];
        let i = startIndex;

        while (i < lines.length) {
            const line = lines[i];
            const match = line.match(/^([\s]*)[-*+]\s+(.+)$/);

            if (!match) break;

            const indent = match[1].length;
            const content = this.parseInline(match[2]);

            if (indent > 0 && listItems.length > 0) {
                listItems[listItems.length - 1] += `<ul><li>${content}</li></ul>`;
            } else {
                listItems.push(`<li>${content}</li>`);
            }

            i++;
        }

        this.html.push('<ul>');
        this.html.push(...listItems);
        this.html.push('</ul>');

        return i;
    }

    parseOrderedList(lines, startIndex) {
        const listItems = [];
        let i = startIndex;

        while (i < lines.length) {
            const line = lines[i];
            const match = line.match(/^([\s]*)\d+\.\s+(.+)$/);

            if (!match) break;

            const indent = match[1].length;
            const content = this.parseInline(match[2]);

            if (indent > 0 && listItems.length > 0) {
                listItems[listItems.length - 1] += `<ol><li>${content}</li></ol>`;
            } else {
                listItems.push(`<li>${content}</li>`);
            }

            i++;
        }

        this.html.push('<ol>');
        this.html.push(...listItems);
        this.html.push('</ol>');

        return i;
    }

    parseTable(lines, startIndex) {
        const tableLines = [];
        let i = startIndex;

        while (i < lines.length && lines[i].includes('|')) {
            tableLines.push(lines[i]);
            i++;
        }

        if (tableLines.length < 2) return i;

        // Parse header
        const headerCells = tableLines[0].split('|')
            .map(cell => cell.trim())
            .filter(cell => cell);

        // Parse alignments
        const separator = tableLines[1];
        const alignments = separator.split('|')
            .map(cell => cell.trim())
            .filter(cell => cell)
            .map(cell => {
                if (cell.startsWith(':') && cell.endsWith(':')) return 'center';
                if (cell.endsWith(':')) return 'right';
                return 'left';
            });

        // Build table
        this.html.push('<table>');

        // Header
        this.html.push('<thead><tr>');
        headerCells.forEach((cell, idx) => {
            const align = alignments[idx] || 'left';
            const content = this.parseInline(cell);
            this.html.push(`<th style="text-align: ${align}">${content}</th>`);
        });
        this.html.push('</tr></thead>');

        // Body
        this.html.push('<tbody>');
        for (let j = 2; j < tableLines.length; j++) {
            const cells = tableLines[j].split('|')
                .map(cell => cell.trim())
                .filter(cell => cell);

            this.html.push('<tr>');
            cells.forEach((cell, idx) => {
                const align = alignments[idx] || 'left';
                const content = this.parseInline(cell);
                this.html.push(`<td style="text-align: ${align}">${content}</td>`);
            });
            this.html.push('</tr>');
        }
        this.html.push('</tbody>');

        this.html.push('</table>');

        return i;
    }

    parseParagraph(lines, startIndex) {
        const paraLines = [];
        let i = startIndex;

        while (i < lines.length) {
            const line = lines[i].trim();

            if (!line) break;
            if (line.startsWith('#') || line.startsWith('>')) break;
            if (line.startsWith('```')) break;
            if (/^[\s]*[-*+]\s+/.test(line)) break;
            if (/^[\s]*\d+\.\s+/.test(line)) break;
            if (/^(\*\*\*+|---+|___+)\s*$/.test(line)) break;

            paraLines.push(line);
            i++;
        }

        if (paraLines.length > 0) {
            const paraText = paraLines.join(' ');
            const paraHtml = this.parseInline(paraText);
            this.html.push(`<p>${paraHtml}</p>`);
        }

        return i;
    }

    parseInline(text) {
        // Escape HTML first
        text = this.escapeHtml(text);

        // Images: ![alt](url)
        text = text.replace(
            /!\[([^\]]*)\]\(([^\)]+)\)/g,
            '<img src="$2" alt="$1">'
        );

        // Links: [text](url)
        text = text.replace(
            /\[([^\]]+)\]\(([^\)]+)\)/g,
            '<a href="$2">$1</a>'
        );

        // Inline code: `code`
        text = text.replace(
            /`([^`]+)`/g,
            '<code>$1</code>'
        );

        // Bold and italic: ***text***
        text = text.replace(
            /\*\*\*(.+?)\*\*\*/g,
            '<strong><em>$1</em></strong>'
        );

        // Bold: **text** or __text__
        text = text.replace(
            /\*\*(.+?)\*\*/g,
            '<strong>$1</strong>'
        );
        text = text.replace(
            /__(.+?)__/g,
            '<strong>$1</strong>'
        );

        // Italic: *text* or _text_
        text = text.replace(
            /\*(.+?)\*/g,
            '<em>$1</em>'
        );
        text = text.replace(
            /_(.+?)_/g,
            '<em>$1</em>'
        );

        // Strikethrough: ~~text~~
        text = text.replace(
            /~~(.+?)~~/g,
            '<del>$1</del>'
        );

        // Unescape for attributes
        text = text.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
        text = text.replace(/href="([^"]*)"/, (match, url) => {
            return `href="${this.unescapeHtml(url)}"`;
        });
        text = text.replace(/src="([^"]*)"/, (match, url) => {
            return `src="${this.unescapeHtml(url)}"`;
        });

        return text;
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    unescapeHtml(text) {
        const div = document.createElement('div');
        div.innerHTML = text;
        return div.textContent || div.innerText || '';
    }
}

// Export for use in app.js
if (typeof module !== 'undefined' && module.exports) {
    module.exports = MarkdownParser;
}

// Markdown to PDF Application
// Main application logic

// Global state
const state = {
    settings: {
        fontFamily: 'Georgia, serif',
        bodySize: 16,
        h1Size: 32,
        h2Size: 24,
        h3Size: 20,
        bgColor: '#ffffff',
        textColor: '#333333',
        headingColor: '#2c3e50',
        linkColor: '#0366d6'
    }
};

// Initialize parser
const parser = new MarkdownParser();

// DOM Elements
let markdownEditor, preview, settingsModal;
let wordCountElement, charCountElement;

// Initialize application
document.addEventListener('DOMContentLoaded', () => {
    // Get DOM elements
    markdownEditor = document.getElementById('markdownEditor');
    preview = document.getElementById('preview');
    settingsModal = document.getElementById('settingsModal');
    wordCountElement = document.getElementById('wordCount');
    charCountElement = document.getElementById('charCount');

    // Event listeners
    markdownEditor.addEventListener('input', handleEditorInput);
    document.getElementById('settingsBtn').addEventListener('click', openSettings);
    document.getElementById('exportBtn').addEventListener('click', exportPDF);

    // Load saved content from localStorage
    loadSavedContent();

    // Initial render
    updatePreview();
});

// Handle editor input
function handleEditorInput() {
    updatePreview();
    updateStats();
    saveContent();
}

// Update preview
function updatePreview() {
    const markdown = markdownEditor.value;

    // Parse markdown
    const html = parser.parse(markdown);

    // Apply custom styles
    const customCSS = generateCustomCSS();

    // Update preview
    if (html) {
        preview.innerHTML = html;
        applyCustomStyles();
    } else {
        preview.innerHTML = '<p class="preview-placeholder">Your rendered markdown will appear here...</p>';
    }
}

// Refresh preview (force update)
function refreshPreview() {
    updatePreview();
}

// Generate custom CSS from settings
function generateCustomCSS() {
    const s = state.settings;

    return `
        .preview-content {
            font-family: ${s.fontFamily};
            font-size: ${s.bodySize}px;
            color: ${s.textColor};
            background-color: ${s.bgColor};
        }

        .preview-content h1 {
            font-size: ${s.h1Size}px;
            color: ${s.headingColor};
        }

        .preview-content h2 {
            font-size: ${s.h2Size}px;
            color: ${s.headingColor};
        }

        .preview-content h3 {
            font-size: ${s.h3Size}px;
            color: ${s.headingColor};
        }

        .preview-content h4,
        .preview-content h5,
        .preview-content h6 {
            color: ${s.headingColor};
        }

        .preview-content a {
            color: ${s.linkColor};
        }
    `;
}

// Apply custom styles to preview
function applyCustomStyles() {
    // Remove old style
    const oldStyle = document.getElementById('customPreviewStyles');
    if (oldStyle) {
        oldStyle.remove();
    }

    // Add new style
    const style = document.createElement('style');
    style.id = 'customPreviewStyles';
    style.textContent = generateCustomCSS();
    document.head.appendChild(style);
}

// Update word and character count
function updateStats() {
    const text = markdownEditor.value;

    // Character count
    const charCount = text.length;

    // Word count (split by whitespace and filter empty strings)
    const words = text.trim().split(/\s+/).filter(word => word.length > 0);
    const wordCount = text.trim().length > 0 ? words.length : 0;

    wordCountElement.textContent = `Words: ${wordCount}`;
    charCountElement.textContent = `Characters: ${charCount}`;
}

// Insert markdown at cursor
function insertMarkdown(before, after) {
    const textarea = markdownEditor;
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const selectedText = textarea.value.substring(start, end);
    const replacement = before + selectedText + after;

    textarea.value = textarea.value.substring(0, start) + replacement + textarea.value.substring(end);

    // Move cursor
    const newCursorPos = start + before.length + selectedText.length;
    textarea.selectionStart = textarea.selectionEnd = newCursorPos;

    textarea.focus();
    updatePreview();
    updateStats();
}

// Insert list
function insertList() {
    const textarea = markdownEditor;
    const start = textarea.selectionStart;
    const selectedText = textarea.value.substring(start, textarea.selectionEnd);

    const listItems = selectedText.split('\n').filter(line => line.trim());
    const formattedList = listItems.length > 0
        ? listItems.map(line => `- ${line}`).join('\n')
        : '- Item 1\n- Item 2\n- Item 3';

    textarea.value = textarea.value.substring(0, start) +
                    formattedList +
                    textarea.value.substring(textarea.selectionEnd);

    textarea.focus();
    updatePreview();
    updateStats();
}

// Settings Modal
function openSettings() {
    // Load current settings
    document.getElementById('fontFamily').value = state.settings.fontFamily;
    document.getElementById('bodySize').value = state.settings.bodySize;
    document.getElementById('h1Size').value = state.settings.h1Size;
    document.getElementById('h2Size').value = state.settings.h2Size;
    document.getElementById('h3Size').value = state.settings.h3Size;
    document.getElementById('bgColor').value = state.settings.bgColor;
    document.getElementById('textColor').value = state.settings.textColor;
    document.getElementById('headingColor').value = state.settings.headingColor;
    document.getElementById('linkColor').value = state.settings.linkColor;

    // Show modal
    settingsModal.classList.add('active');
}

function closeSettings() {
    settingsModal.classList.remove('active');
    saveSettings();
}

// Update settings from form
function updateSettingsFromForm() {
    state.settings.fontFamily = document.getElementById('fontFamily').value;
    state.settings.bodySize = parseInt(document.getElementById('bodySize').value);
    state.settings.h1Size = parseInt(document.getElementById('h1Size').value);
    state.settings.h2Size = parseInt(document.getElementById('h2Size').value);
    state.settings.h3Size = parseInt(document.getElementById('h3Size').value);
    state.settings.bgColor = document.getElementById('bgColor').value;
    state.settings.textColor = document.getElementById('textColor').value;
    state.settings.headingColor = document.getElementById('headingColor').value;
    state.settings.linkColor = document.getElementById('linkColor').value;
}

// Apply preset theme
function applyPreset(presetName) {
    const presets = {
        default: {
            fontFamily: 'Georgia, serif',
            bodySize: 16,
            h1Size: 32,
            h2Size: 24,
            h3Size: 20,
            bgColor: '#ffffff',
            textColor: '#333333',
            headingColor: '#2c3e50',
            linkColor: '#0366d6'
        },
        dark: {
            fontFamily: 'Arial, sans-serif',
            bodySize: 16,
            h1Size: 32,
            h2Size: 24,
            h3Size: 20,
            bgColor: '#1e1e1e',
            textColor: '#e0e0e0',
            headingColor: '#4fc3f7',
            linkColor: '#81c784'
        },
        minimal: {
            fontFamily: "'Helvetica Neue', Helvetica, sans-serif",
            bodySize: 14,
            h1Size: 28,
            h2Size: 20,
            h3Size: 18,
            bgColor: '#fafafa',
            textColor: '#424242',
            headingColor: '#212121',
            linkColor: '#1976d2'
        },
        serif: {
            fontFamily: "'Times New Roman', Times, serif",
            bodySize: 18,
            h1Size: 36,
            h2Size: 28,
            h3Size: 22,
            bgColor: '#f5f5dc',
            textColor: '#2f2f2f',
            headingColor: '#8b4513',
            linkColor: '#b8860b'
        }
    };

    const preset = presets[presetName];
    if (preset) {
        state.settings = { ...preset };

        // Update form
        document.getElementById('fontFamily').value = preset.fontFamily;
        document.getElementById('bodySize').value = preset.bodySize;
        document.getElementById('h1Size').value = preset.h1Size;
        document.getElementById('h2Size').value = preset.h2Size;
        document.getElementById('h3Size').value = preset.h3Size;
        document.getElementById('bgColor').value = preset.bgColor;
        document.getElementById('textColor').value = preset.textColor;
        document.getElementById('headingColor').value = preset.headingColor;
        document.getElementById('linkColor').value = preset.linkColor;

        updatePreview();
    }
}

// Reset settings to default
function resetSettings() {
    applyPreset('default');
}

// Export to PDF
function exportPDF() {
    // Update settings before export
    updateSettingsFromForm();

    // Apply print-optimized styles
    const printStyles = generatePrintCSS();

    // Create style element for print
    const printStyle = document.createElement('style');
    printStyle.id = 'printStyles';
    printStyle.media = 'print';
    printStyle.textContent = printStyles;
    document.head.appendChild(printStyle);

    // Trigger browser print dialog
    window.print();

    // Remove print styles after a delay
    setTimeout(() => {
        const element = document.getElementById('printStyles');
        if (element) {
            element.remove();
        }
    }, 1000);
}

// Generate print CSS
function generatePrintCSS() {
    const s = state.settings;

    return `
        @page {
            margin: 1in;
        }

        @media print {
            body {
                font-family: ${s.fontFamily};
                font-size: ${s.bodySize}px;
                color: ${s.textColor};
                background-color: ${s.bgColor};
            }

            h1 {
                font-size: ${s.h1Size}px;
                color: ${s.headingColor};
            }

            h2 {
                font-size: ${s.h2Size}px;
                color: ${s.headingColor};
            }

            h3 {
                font-size: ${s.h3Size}px;
                color: ${s.headingColor};
            }

            h4, h5, h6 {
                color: ${s.headingColor};
            }

            a {
                color: ${s.linkColor};
            }

            .preview-content {
                max-width: none;
                padding: 0;
            }
        }
    `;
}

// Save content to localStorage
function saveContent() {
    try {
        localStorage.setItem('markdown-content', markdownEditor.value);
    } catch (e) {
        console.error('Failed to save content:', e);
    }
}

// Load saved content from localStorage
function loadSavedContent() {
    try {
        const saved = localStorage.getItem('markdown-content');
        if (saved) {
            markdownEditor.value = saved;
        }
    } catch (e) {
        console.error('Failed to load saved content:', e);
    }
}

// Save settings to localStorage
function saveSettings() {
    updateSettingsFromForm();
    try {
        localStorage.setItem('markdown-settings', JSON.stringify(state.settings));
    } catch (e) {
        console.error('Failed to save settings:', e);
    }
}

// Load saved settings from localStorage
function loadSavedSettings() {
    try {
        const saved = localStorage.getItem('markdown-settings');
        if (saved) {
            state.settings = { ...state.settings, ...JSON.parse(saved) };
        }
    } catch (e) {
        console.error('Failed to load saved settings:', e);
    }
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    // Ctrl/Cmd + B: Bold
    if ((e.ctrlKey || e.metaKey) && e.key === 'b') {
        e.preventDefault();
        insertMarkdown('**', '**');
    }

    // Ctrl/Cmd + I: Italic
    if ((e.ctrlKey || e.metaKey) && e.key === 'i') {
        e.preventDefault();
        insertMarkdown('*', '*');
    }

    // Ctrl/Cmd + K: Link
    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
        e.preventDefault();
        insertMarkdown('[', '](url)');
    }

    // Ctrl/Cmd + E: Inline code
    if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
        e.preventDefault();
        insertMarkdown('`', '`');
    }

    // Ctrl/Cmd + P: Export PDF
    if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
        e.preventDefault();
        exportPDF();
    }

    // Ctrl/Cmd + S: Save (already auto-saves, but confirm)
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        saveContent();
        // Show brief confirmation
        const header = document.querySelector('.header h1');
        const originalText = header.textContent;
        header.textContent = 'üíæ Saved!';
        setTimeout(() => {
            header.textContent = originalText;
        }, 1000);
    }
});

// Load saved settings on startup
loadSavedSettings();
    </script>
</body>
</html>
